

## Flutter

## flutter环境搭建和Hello  Wrold

### 让Flutter跑起来

虚拟机运行以后，可以点击`debug`按钮，让Flutter程序跑起来。如果你幸运的话，你的Flutter程序经过编译后，就会跑起来了。（这种幸运的机会很小，总会碰到一些小错误，我在这里介绍两个常见的错误）。

### Error runing Gradle 错误解决（1.x版本已经修复）

在Debug项目的时候，应该最常见的错误就是类似下面这样的错误了。

```
Launching lib/main.dart on Android SDK built for x86 in debug mode...
Initializing gradle...
Resolving dependencies...
* Error running Gradle:
ProcessException: Process "/Users/rabbit/develop/android/flutter_app/android/gradlew" exited abnormally:
Project evaluation failed including an error in afterEvaluate {}. Run with --stacktrace for details of the afterEvaluate {} error.

FAILURE: Build failed with an exception.

* Where:
Build file '/Users/rabbit/develop/android/flutter_app/android/app/build.gradle' line: 25

* What went wrong:
A problem occurred evaluating project ':app'.
> Could not resolve all files for configuration 'classpath'.
   > Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2).
     Searched in the following locations:
         https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 0s
  Command: /Users/rabbit/develop/android/flutter_app/android/gradlew app:properties
Finished with error: Please review your Gradle project setup in the android/ folder.
```

这个问题的产生的原因，还是中国特有的问题，解决方案是改位阿里的链接(1.0已经修复了这个问题，不用再重新设置了)。

第一步：修改掉项目下的android目录下的`build.gradle`文件，把google() 和 jcenter()这两行去掉。改为阿里的链接。

```
maven { url 'https://maven.aliyun.com/repository/google' }
maven { url 'https://maven.aliyun.com/repository/jcenter' }
maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
```

全部代码：

```
buildscript {
    repositories {
        //  google()
        //  jcenter()
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public'}
        }
        dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }
}

allprojects {
    repositories {
        // google()
        // jcenter()
        maven { url 'https://maven.aliyun.com/repository/google' }
        maven { url 'https://maven.aliyun.com/repository/jcenter' }
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }
    }
}

rootProject.buildDir = '../build'
subprojects {
    project.buildDir = "${rootProject.buildDir}/${project.name}"
}
subprojects {
    project.evaluationDependsOn(':app')
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
```

注意是有两个部分进行了修改，不要只修改一处。

第二步：修改Flutter SDK包下的`flutter.gradle`文件,这个目录要根据你的SDK存放的位置有所变化。比如我放在了D盘Flutter目录下，那路径就是这个。

```
D:\Flutter\flutter\packages\flutter_tools\gradle
```

打开文件进行修改，修改代码如下（其实也是换成阿里的路径就可以了）。

```
buildscript {
    repositories {
        //jcenter()
        // maven {
        //     url 'https://dl.google.com/dl/android/maven2'
        // }
        maven{
            url 'https://maven.aliyun.com/repository/jcenter'
        }
        maven{
            url 'http://maven.aliyun.com/nexus/content/groups/public'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }
}
```

然后再重新Debug一下，就基本可以启动起来。

还有一种错误是说硬件没有启动GPU，需要下载安装一个程序，这个提示的很清楚，不做过多的介绍了

### VSCode下如何玩转Flutter

### 一条命令快速开启虚拟机

现在想开启虚拟机需要打开`Android Studio`,然后再打开AVD虚拟机，我的电脑足足要等2分钟左右(土豪电脑除外)，我反正是不能接受的，一点不符合极客精神。下面就用一条命令，或者说制作一个批处理文件，来直接开启AVD虚拟机，这样就不用再等两分钟来开启`Android Studio`了。

**开启虚拟机需要两个步骤：**

1. 打开`emulator.exe`这个程序，你可以巧妙利用windows的查找工具进行查找。
2. 打开你设置的虚拟机，批处理时需要填写你设置的虚拟机名称。

**具体步骤如下：**

1. 新建一个`xxx.bat`文件到桌面，xxx的意思是，你可以自己取名字，随意叫什么都可以。我这里叫`EmulatorRun.bat`.
2. 查找`emulator.exe`文件的路径，把查找到的路径放到bat文件中，你一般会查找到两个emulator.exe文件，一个是在tools目录下，一个是在emulator目录下，我们选择`emulator`目录下的这个,复制它的路径。

```
C:\Users\Administrator\AppData\Local\Android\Sdk\emulator\emulator.exe
```

(特别说明，你的和我的很有可能不一样，你要复制i电脑中的路径，不要复制这里的代码)

1. 打开`Android Studio`，并查看你的AVD虚拟机名称 如果你觉的输入不方便和怕出错，你可以点击图片后边的笔型按钮，进入编辑模式，复制这个名称。 
2. 然后根据你复制的名称，把bat文件输入成如下形式。

```
C:\Users\Administrator\AppData\Local\Android\Sdk\emulator\emulator.exe -netdelay none -netspeed full -avd Nexus_5X_API_28
```

进行保存后双击bat文件，就可以迅速打开虚拟机了。

**参数解释：**

- -netdelay none :设置模拟器的网络延迟时间，默认为none，就是没有延迟。
- -netspeed full: 设置网络加速值，full代表全速。

### flutter run 开启预览

现在模拟器也有了，VSCode也支持Flutter开发了.现在可以在VSCode中直接打开终端，快捷键是`ctrl+~`，然后在终端中输入下面的命令。

```
flutter run
```

经过短暂的编译后就会启动我们的程序了（如图）。

到此处，终于搭建出了适合前端程序员的开发环境，下节课开始，我们正式来学习Flutter代码的编写知识。

我们来看几个重点的：

- r 键：点击后热加载，也就算是重新加载吧。
- p 键：显示网格，这个可以很好的掌握布局情况，工作中很有用。
- o 键：切换android和ios的预览模式。
- q 键：退出调试预览模式。

## Flutter常用 组件 

### Text Widget 文本组件的使用

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class  MyApp extends  StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'Text widget',
      home: Scaffold(
        body: Center(
          child: Text(
            'Hello,widget,qewqeqweqweeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee',
            textAlign: TextAlign.center,
            maxLines: 1,  //最大显示条数
            overflow: TextOverflow.ellipsis,  //fade 产生渐变 ellipsis 产生3个点 clip 全部隐藏
            style: TextStyle(
              fontSize: 25.0,
              color: Color.fromARGB(255, 255, 125, 125),
              decoration: TextDecoration.underline,
              decorationStyle: TextDecorationStyle.solid,
            ),
          ),
        ),
      )
    );
  }
}
```

#### textAlign属性 

textAlign属性就是文本的对齐方式，它的属性值有如下几个：

- center: 文本以居中形式对齐,这个也算比较常用的了。
- left:左对齐，经常使用，让文本居左进行对齐，效果和start一样。
- right :右对齐，使用频率也不算高。
- start:以开始位置进行对齐，类似于左对齐。
- end: 以为本结尾处进行对齐，不常用。有点类似右对齐.

#### maxLines属性

设置最多显示的行数，比如我们现在只显示1行，   设置好即文字只显示一行

#### overflow属性

overflow属性是用来设置文本溢出时，如何处理,它有下面几个常用的值供我们选择。

- clip：直接切断，剩下的文字就没有了，感觉不太友好，体验性不好。
- ellipsis:在后边显示省略号，体验性较好，这个在工作中经常使用。
- fade: 溢出的部分会进行一个渐变消失的效果，当然是上线的渐变，不是左右的哦。

### style属性

style属性的内容比较多，具体的你可以查一下API

更详细的属性资料可以参看这个网址：https://docs.flutter.io/flutter/painting/TextStyle-class.html

### Container容器组件的使用

#### alignment属性

这个属性针对的是Container内child的对齐方式，也就是容器子内容的对齐方式，并不是容器本身的对齐方式。

- bottomCenter:下部居中对齐。
- botomLeft: 下部左对齐。
- bottomRight：下部右对齐。
- center：纵横双向居中对齐。
- centerLeft：纵向居中横向居左对齐。
- centerRight：纵向居中横向居右对齐。
- topLeft：顶部左侧对齐。
- topCenter：顶部居中对齐。
- topRight： 顶部居左对齐。

#### 设置宽、高和颜色属性

设置宽、高和颜色属性是相对容易的，只要在属性名称后面加入浮点型数字就可以了，比如要设置宽是500，高是400，颜色为亮蓝色。

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends  StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'Text widget',
      home: Scaffold(
        body: Center(
          child: Container(
            child: new Text('Hello world', style: TextStyle(fontSize: 40.0)),
            alignment: Alignment.center,
            width: 500.0,
            height: 400.0,
            color: Colors.lightBlue,
          )
        ),
      )
    );
  }
}
```

#### padding属性

padding的属性就是一个内边距，它和你使用的前端技术CSS里的`padding`表现形式一样。

#### margin属性

margin是外边距，只的是container和外部元素的距离。

#### decoration属性

decoration是 container 的修饰器，主要的功能是设置背景和边框。

比如你需要给背景加入一个渐变，这时候需要使用BoxDecoration这个类

#### border属性

设置边框可以在decoration里设置border属性

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends  StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'Text widget',
      home: Scaffold(
        body: Center(
          child: Container(
            child: new Text('Hello world', style: TextStyle(fontSize: 40.0)),
            alignment: Alignment.center,
            width: 500.0,
            height: 400.0,
            padding: const EdgeInsets.fromLTRB(10.0, 30.0, 0.0, 0.0),
            margin: const EdgeInsets.all(10.0),
            decoration: new BoxDecoration(
              gradient: const LinearGradient(
                colors: [Colors.lightBlue,Colors.greenAccent,Colors.purple]
              ),
              border: Border.all(width: 2.0,color: Colors.red)
            ),
          )
        ),
      )
    );
  }
}
```

### Image图片组件的 使用

#### 加入图片的 方式

- **Image.asset**:加载资源图片，就是加载项目资源目录中的图片,加入图片后会增大打包的包体体积，用的是相对路径。
- **Image.network**:网络资源图片，意思就是你需要加入一段http://xxxx.xxx的这样的网络路径地址。
- **Image.file**:加载本地图片，就是加载本地文件中的图片，这个是一个绝对路径，跟包体无关。
- **Image.memory**: 加载Uint8List资源图片,这个我目前用的不是很多，所以没什么发言权。

#### fit属性的设置

fit属性可以控制图片的拉伸和挤压，这些都是根据图片的父级容器来的，我们先来看看这些属性（建议此部分组好看视频理解）。

- **BoxFit.fill**:全图显示，图片会被拉伸，并充满父容器。
- **BoxFit.contain**:全图显示，显示原比例，可能会有空隙。
- **BoxFit.cover**：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。
- **BoxFit.fitWidth**：宽度充满（横向充满），显示可能拉伸，可能裁切。
- **BoxFit.fitHeight** ：高度充满（竖向充满）,显示可能拉伸，可能裁切。
- **BoxFit.scaleDown**：效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。

#### repeat图片重复

- **ImageRepeat.repeat ** : 横向和纵向都进行重复，直到铺满整个画布。
- **ImageRepeat.repeatX **: 横向重复，纵向不重复。
- **ImageRepeat.repeatY **：纵向重复，横向不重复。

### listView组件的使用

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends  StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'listView widget',
      home: Scaffold(
        appBar: new AppBar(title: new Text('listView widget')),
        body: new ListView(
          children: <Widget>[
            new ListTile(
              leading: new Icon(Icons.accessibility),
              title: new Text('accessibility'),
            ),
             new ListTile(
              leading: new Icon(Icons.adb),
              title: new Text('accessibility'),
            ),
          ],
        ),
      )
    );
  }
}
```

#### listView横向组件

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends  StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'listView widget',
      home: Scaffold(
        appBar: new AppBar(title: new Text('listView widget')),
        body: Center(
          child: Container(
            height: 200.0,
            child: new ListView(
              scrollDirection: Axis.horizontal, // 横向 Axis.vertical //纵向
              children: <Widget>[
                new Container(
                  width: 180.0,
                  color: Colors.lightBlue,
                ),
                new Container(
                  width: 180.0,
                  color: Colors.amber, //黄色
                ),
                new Container(
                  width: 180.0,
                  color: Colors.deepPurple,
                ),
                new Container(
                  width: 180.0,
                  color: Colors.deepOrange,
                )
              ],
            ),
          ),
        )
      )
    );
  }
}
```

#### listView动态列表

**List类型的使用**

List是Dart的集合类型之一,其实你可以把它简单理解为数组（反正我是这么认为的），其他语言也都有这个类型。它的声明有几种方式：

- `var myList = List()`: 非固定长度的声明。
- `var myList = List(2)`: 固定长度的声明。
- `var myList= List<String>()`:固定类型的声明方式。
- `var myList = [1,2,3]`: 对List直接赋值。

那我们这里使用的是一个List传递，然后直接用List中的`generate`方法进行生产List里的元素。最后的结果是生产了一个带值的List变量。代码如下：

```
void main () => runApp(MyApp(
  items: new List<String>.generate(1000, (i)=> "Item $i")
));
```

说明:再`main`函数的runApp中调用了MyApp类，再使用类的使用传递了一个`items`参数,并使用generate生成器对`items`进行赋值。

generate方法传递两个参数，第一个参数是生成的个数，第二个是方法

**接收参数**

我们已经传递了参数，那MyApp这个类是需要接收的。

```
final List<String> items;
MyApp({Key key, @required this.items}):super(key:key);
```

这是一个构造函数，除了Key，我们增加了一个必传参数，这里的`@required`意思就必传。`:super`如果父类没有无名无参数的默认构造函数，则子类必须手动调用一个父类构造函数。

这样我们就可以接收一个传递过来的参数了，当然我们要事先进行声明。

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp(
  items: new List<String>.generate(1000, (i) => "Item $i")
));

class MyApp extends StatelessWidget{
  final List<String> items;
  MyApp({Key key,@required this.items}):super(key:key);
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'listView widget',
      home: Scaffold(
        appBar: new AppBar(title: new Text('listView widget')),
        body: new ListView.builder(
          itemCount: 1000,
          itemBuilder: (context, index) {
            return ListTile (
              title: new Text('${items[index]}'),
            );
          },
        )
      )
    );
  }
}
```

### GridView网格列表组件

我们在body属性中加入了网格组件，然后给了一些常用属性:

- padding:表示内边距，这个小伙伴们应该很熟悉。
- crossAxisSpacing:网格间的空当，相当于每个网格之间的间距。
- crossAxisCount:网格的列数，相当于一行放置的网格数量。

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'listView widget',
      home: Scaffold(
        appBar: new AppBar(title: new Text('listView widget')),
        body: GridView.count(
          padding: const EdgeInsets.all(20.0),
          crossAxisSpacing: 10.0,
          crossAxisCount: 3,
          children: <Widget>[
            const Text('I am sufan'),
            const Text('I love Web'),
            const Text('jspang.com'),
            const Text('我喜欢玩游戏'),
            const Text('我喜欢看书'),
            const Text('我喜欢吃火锅')
          ],
        )
      )
    );
  }
}

```

#### 图片网格

- childAspectRatio:宽高比，这个值的意思是宽是高的多少倍，如果宽是高的2倍，那我们就写2.0，如果高是宽的2倍，我们就写0.5。希望小伙伴们理解一下。

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends StatelessWidget{
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'listView widget',
      home: Scaffold(
        appBar: new AppBar(title: new Text('listView widget')),
        body: GridView(
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3,
            mainAxisSpacing: 2.0,
            crossAxisSpacing: 2.0,
            childAspectRatio: 0.7
          ),
          children: <Widget>[
            new Image.network('http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/10/10/112514.30587089_180X260X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/13/093605.61422332_180X260X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/07/092515.55805319_180X260X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/21/090246.16772408_135X190X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/17/162028.94879602_135X190X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/19/165350.52237320_135X190X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/16/115256.24365160_180X260X4.jpg',fit: BoxFit.cover),
             new Image.network('http://img5.mtime.cn/mt/2018/11/20/141608.71613590_135X190X4.jpg',fit: BoxFit.cover),
          ],
        )
      )
    );
  }
}
```

### rowWidget布局

#### 不灵活布局

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'row widget Demo',
      home: Scaffold(
        appBar:  new AppBar(
          title: new Text('水平方向布局'),
        ),
        body: new Row(
          children: <Widget>[
            new RaisedButton(
              onPressed: () {},
              color: Colors.redAccent,
              child: new Text('red Button'),
            ),
            new RaisedButton(
              onPressed: () {},
              color: Colors.orangeAccent,
              child: new Text('orange Button'),
            ),
            new RaisedButton(
              onPressed: () {},
              color: Colors.pinkAccent,
              child: new Text('pink Button'),
            ),
          ],
        ),
      ),
    );
  }
}
```

这时候你会发现的页面已经有了三个按钮，但这三个按钮并没有充满一行，而是出现了空隙。这就是不灵活横向排列造成的。它根据子元素的大小来进行排列。如果我们想实现充满一行的效果，就要使用灵活水平布局了。

#### 灵活布局

```
Expanded(child:
    new RaisedButton(
    onPressed: () {},
    color: Colors.redAccent,
    child: new Text('red Button'),
  ),
),
```

### 垂直布局Column组件

#### column基本用法

左对齐只要在column组件下加入下面的代码，就可以让文字左对齐。

```
crossAxisAlignment: CrossAxisAlignment.start,
```

- CrossAxisAlignment.star：居左对齐。
- CrossAxisAlignment.end：居右对齐。
- CrossAxisAlignment.center：居中对齐。

#### 主轴和副轴的认识

在设置对齐方式的时候你会发现右mainAxisAlignment属性，意思就是主轴对齐方式，那什么是主轴，什么又是幅轴那。

- main轴：如果你用column组件，那垂直就是主轴，如果你用Row组件，那水平就是主轴。
- cross轴：cross轴我们称为幅轴，是和主轴垂直的方向。比如Row组件，那垂直就是幅轴，Column组件的幅轴就是水平方向的。

主轴和幅轴我们搞清楚，才能在实际工作中随心所欲的进行布局。

比如现在我们要把上面的代码，改成垂直方向居中。因为用的是Column组件，所以就是主轴方向，这时候你要用的就是主轴对齐了。

```
mainAxisAlignment: MainAxisAlignment.center,
```

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context){
    return MaterialApp(
      title: 'row widget Demo',
      home: Scaffold(
        appBar:  new AppBar(
          title: new Text('水平方向布局'),
        ),
        body:Center(child:
            Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Expanded(child:  Text('sufan sufan')),
              Expanded (child: Text('flutter 是未来的发展方向')),
              Text('I love coding')
            ],
          )
        )
      ),
    );
  }
}
```



### stack重叠布局

#### 层叠布局的 alignment 属性

alignment属性是控制层叠的位置的，建议在两个内容进行层叠时使用。它有两个值X轴距离和Y轴距离，值是从0到1的，都是从上层容器的左上角开始算起的。

#### CircleAvatar组件的使用

`CircleAvatar`这个经常用来作头像的，组件里边有个`radius`的值可以设置图片的弧度。

现在我们准备放入一个图像，然后把弧度设置成100，形成一个漂亮的圆形，代码如下：

```
new CircleAvatar(
  backgroundImage: new NetworkImage('http://jspang.com/static//myimg/blogtouxiang.jpg'),
  radius: 100.0,
),
```

```
import 'package:flutter/material.dart';

void main () => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context){
    var stack = new Stack(
      alignment: const FractionalOffset(0.5, 0.8),
      children: <Widget>[
        new CircleAvatar(
          backgroundImage: new NetworkImage('http://blogimages.jspang.com/blogtouxiang1.jpg'),
          radius: 100,
        ),
        new Container(
          decoration: new BoxDecoration(
            color: Colors.lightBlue
          ),
          padding: EdgeInsets.all(10.0),
          child: Text('sufan'),
        )
      ],
    );
    return MaterialApp(
      title: 'row widget Demo',
      home: Scaffold(
        appBar:  new AppBar(
          title: new Text('stack布局'),
        ),
        body:Center(
          child: stack,
        )
      ),
    );
  }
}
```

#### Stack的Positioned属性

### Positioned组件的属性

- bottom: 距离层叠组件下边的距离
- left：距离层叠组件左边的距离
- top：距离层叠组件上边的距离
- right：距离层叠组件右边的距离
- width: 层叠定位组件的宽度
- height: 层叠定位组件的高度

```
new Positioned(
  top: 10.0,
  left: 10.0,
  child: new Text('1111111111'),
),
new Positioned(
  bottom: 10.0,
  right: 10.0,
  child: new Text('222222222'),
)
```

### 卡片组件布局

```
import 'package:flutter/material.dart';
import 'package:flutter/painting.dart';

void main () => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context){
    var card = new Card(
      child: Column(
        children: <Widget>[
          ListTile(
            title: Text('山西省晋城市陵川县', style: TextStyle(fontWeight: FontWeight.w500)),
            subtitle: Text('苏凡：2222222222222'),
            leading: new Icon(Icons.account_box, color: Colors.lightBlue),
          ),
          new Divider(),
          ListTile(
            title: Text('陕西省西安市', style: TextStyle(fontWeight: FontWeight.w500)),
            subtitle: Text('苏222：222221311'),
            leading: new Icon(Icons.account_box, color: Colors.lightBlue),
          ),
          new Divider(),
          ListTile(
            title: Text('北京市', style: TextStyle(fontWeight: FontWeight.w500)),
            subtitle: Text('苏3333：222221311'),
            leading: new Icon(Icons.account_box, color: Colors.lightBlue),
          ),
        ],
      ),
    );
    return MaterialApp(
      title: 'row widget Demo',
      home: Scaffold(
        appBar:  new AppBar(
          title: new Text('stack布局'),
        ),
        body:Center(
          child: card,
        )
      ),
    );
  }
}
```

### 一般页面导航和返回

#### RaisedButton按钮组件

它有两个最基本的属性：

- child：可以放入容器，图标，文字。让你构建多彩的按钮。
- onPressed：点击事件的相应，一般会调用`Navigator`组件。

我们在作页面导航时，大量的使用了`RaisedButton`组件，这个组件的使用在实际工作中用的也比较多。

#### Navigator.push 和 Navigator.pop

- `Navigator.push`：是跳转到下一个页面，它要接受两个参数一个是上下文`context`，另一个是要跳转的函数。
- `Navigator.pop`：是返回到上一个页面，使用时传递一个context（上下文）参数，使用时要注意的是，你必须是有上级页面的，也就是说上级页面使用了`Navigator.push`。

```
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(
    title: '导航演示01',
    home: new FirstScreen(),
  ));
}

class FirstScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('导航页面')),
      body: Center(
        child: RaisedButton(
          child: Text('查看商品想起页'),
          onPressed: () {
            Navigator.push(context, MaterialPageRoute(
              builder: (context) => new SecondScreen()
            ));
          },
        ),
      ),
    );
  }
}

class SecondScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context){
    return Scaffold(
      appBar: AppBar(title: Text('商品详情页')),
      body: Center(
        child: RaisedButton(
          child: Text('返回'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ),
    );
  }
}
```

### 导航参数的传递和接收

#### 声明数据结构

Dart中可以使用类来抽象一个数据，比如我们模仿一个商品信息，有商品标题和商品描述。我们定义了一个Product类，里边有两个字符型变量，title和description。

- title:是商品标题。
- description: 商品详情描述

代码如下:

```
class Product{
  final String title;  //商品标题
  final String description;  //商品描述
  Product(this.title,this.description);
}
```

### 构建一个商品列表

作一个商品的列表，这里我们采用动态的构造方法，在主方法里传递一个商品列表（List）到自定义的Widget中。

先来看看主方法的编写代码:

```
void main(){
  runApp(MaterialApp(
    title:'数据传递案例',
    home:ProductList(
      products:List.generate(
        20, 
        (i)=>Product('商品 $i','这是一个商品详情，编号为:$i')
      ),
    )
  ));
}
```

上面的代码是主路口文件，主要是在home属性中，我们使用了ProductList，这个自定义组件，而且时候会报错，因为我们缺少这个组件。这个组件我们传递了一个products参数，也就是商品的列表数据，这个数据是我们用`List.generate`生成的。并且这个生成的List原型就是我们刚开始定义的Product这个类（抽象数据）。

ProductList自定义组件的代码：

```
class ProductList extends StatelessWidget{
  final List<Product> products;
  ProductList({Key key,@required this.products}):super(key:key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title:Text('商品列表')),
      body:ListView.builder(
        itemCount:products.length,
        itemBuilder: (context,index){
          return ListTile(
            title:Text(products[index].title),
            onTap:(){
            }
          );
        },
      )
    );
  }
}

```

先接受了主方法传递过来的参数，接受后用`ListView.builder`方法，作了一个根据传递参数数据形成的动态列表。

#### 导航参数的传递

我们还是使用`Navigator`组件，然后使用路由`MaterialPageRoute`传递参数，具体代码如下。

```
Navigator.push(
  context, 
  MaterialPageRoute(
    builder:(context)=>new ProductDetail(product:products[index])
  )
);

```

这段代码要写在onTap相应事件当中。这时候`ProductDetail`会报错，因为我们还没有生命这个组件或者说是类。

#### 子页面接受参数并显示

现在需要声明`ProductDetail`这个类（组件），先要作的就是接受参数，具体代码如下。

```
class ProductDetail extends StatelessWidget {
  final Product product;
  ProductDetail({Key key ,@required this.product}):super(key:key);


  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      appBar: AppBar(
        title:Text('${product.title}'),
      ),
      body:Center(child: Text('${product.description}'),)
    );
  }
}

```

先接受了参数，并把数据显示在了页面中。

```javascript
import 'package:flutter/material.dart';

class Product {
  final String title; //商品标题
  final String description; //商品描述
  Product(this.title, this.description);
}
void main() {
  runApp(MaterialApp(
    title: '导航的数据传递和接收',
    home: ProductList(
      products: List.generate(20, (i) => Product('商品 $i', '这是一个商品详情，编号为：$i'))
    ),
  ));
}

class ProductList extends StatelessWidget {
  final List<Product>products;
  ProductList({Key key,@required this.products}):super(key: key);
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('商品列表')),
      body: ListView.builder(
        itemCount: products.length,
        itemBuilder: (context,index) {
          return ListTile(
            title: Text(products[index].title),
            onTap: () {
              Navigator.push(context, MaterialPageRoute(
                builder: (context) => ProductDetail(product:products[index])
              ));
            },
          );
        },
      ),
    );
  }
}

class ProductDetail extends StatelessWidget {
  final Product product;
  ProductDetail({Key key, @required this.product});
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('${product.title}')),
      body: Center(child: Text('${product.description}'))
    );
  }
}
```

### 页面跳转并返回数据

#### 异步等待请求

### 异步请求和等待

Dart中的异步请求和等待和ES6中的方法很像，直接使用async...await就可以实现。比如下面作了一个找小姐姐的方法，然后进行跳转，注意这时候是异步的。等待结果回来之后，我们再显示出来内容。具体代码如下：

```
  _navigateToXiaoJieJie(BuildContext context) async{ //async是启用异步方法

    final result = await Navigator.push(//等待
      context, 
      MaterialPageRoute(builder: (context)=> XiaoJieJie())
      );
      
      Scaffold.of(context).showSnackBar(SnackBar(content:Text('$result')));
  }
}
```

#### SnackBar的使用

`SnackBar`是用户操作后，显示提示信息的一个控件，类似`Tost`，会自动隐藏。`SnackBar`是以`Scaffold`的`showSnackBar`方法来进行显示的。

```
Scaffold.of(context).showSnackBar(SnackBar(content:Text('$result')));
```

### 返回数据的方式

返回数据其实是特别容易的，只要在返回时带第二个参数就可以了。

```
 Navigator.pop(context,'xxxx');  //xxx就是返回的参数
```

```
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      title: '页面跳转并返回数据',
      home: FirstPage()
    )
  );
}

class FirstPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('找小姐姐要电话')),
      body: Center(
        child: RouteButton(),
      ),
    );
  }
}

class RouteButton extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return RaisedButton(
      onPressed: () {
        _navigatoToXiaoJieJie(context);
      },
      child: Text('去找小姐姐'),
    );
  }
  _navigatoToXiaoJieJie(BuildContext context) async{
    final result = await Navigator.push(context, MaterialPageRoute(
      builder: (context) => XiaoJieJie()
    ));
    Scaffold.of(context).showSnackBar(SnackBar(content:Text('$result')));
  }
}

class XiaoJieJie extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold (
      appBar: AppBar(title: Text('小姐姐')),
      body: Center(
        child:Column(
          children: <Widget>[
            RaisedButton(
              child: Text('大长腿小姐姐'),
              onPressed: () {
                Navigator.pop(context, '大长腿小姐姐：1510123456');
              },
            ),
            RaisedButton(
              child: Text('小蛮腰小姐姐'),
              onPressed: () {
                Navigator.pop(context, '小蛮腰小姐姐：15188888888');
              },
            ),
          ],
        ),
      ),
    );
  }
}
```

### 静态资源和项目图片的处理

配置pubspec.yaml 下面的assets

## Flutter客户端打包







## Flutter实战

- Dio库的使用 （发送http请求）
- Swiper插件技巧
- 企业级路由配置Fluro
- 屏幕视频
- 上拉加载效果制作
- 本地存储功能
- 复杂页面布局
- 超50个Widget的使用
- 随时增加的知识技巧